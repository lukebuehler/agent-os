syntax = "proto3";
//import "google/protobuf/empty.proto";
//import "aos/runtime/apex/test.proto";

// Internal service for worker nodes to communicate with the Apex node
service ApexWorkers {
  // Registers a worker to get ready for a streaming connection.
  rpc RegisterWorker(WorkerRegistrationRequest) returns (WorkerRegistrationResponse) {}
  // Connects a long running worker to the apex node via two-way streaming. Worker needs to register first.
  rpc ConnectWorker(stream WorkerToApexMessage) returns (stream ApexToWorkerMessage) {}
}


message WorkerRegistrationRequest {
  string worker_id = 1;
}

message WorkerRegistrationResponse {
  string ticket = 1; //used to connect to the stream
}

message WorkerManifest{
  string worker_id = 1;
  map<string, string> capabilities = 10; //what capabilities can it satisfy
  repeated Agent current_agents = 20; //not allowed to have any workers in it on READY (aka connect)
  repeated bytes desired_agents = 21; //the agents that the worker wants to have (maybe because it had them previosuly, local caches, etc)
  //capacity, load, etc so that apex can decide where to send agents
}

message Agent{
  bytes agent_id = 1; //32 bytes, of actor_id type
  string agent_did = 2;
  string store_address = 3; //how to connect to the data store of this agent
  map<string, string> capabilities = 10; //what capabilities are requested by the agent
  //map<string, string> workers = 20; //worker_id, worker_address - > for later, what workers are assigned to this agent, so that workers can coordinate
}

message AgentAssignment{
  bytes agent_id = 1;  //required
  optional Agent agent = 2; //only needed when giving to worker
  //todo: reason for assignment, maybe also what actors
}

message MessageInjection {
  bytes agent_id = 1;
  bytes recipient_id = 2;

  oneof message {
    //externally crafted message, with a valid message structure (advanced use case)
    bytes message_id = 5;
    //message_id will be created by runtime by creating the required Grit objects
    InjectMessageData message_data = 6; 
  }
}

message InjectMessageData{
  map <string, string> headers = 3;
  bool is_signal = 4;
  oneof content {
    //blob_id or tree_id (see Grit Message)
    bytes content_id = 5;
    //valid serialized Grit blob object  
    bytes content_blob = 6; 
  }
}

message Query{
  bytes agent_id = 1; //32 bytes, of actor_id type
  bytes actor_id = 2; //32 bytes, actor_id
  string query_id = 3; //correlation_id for this query
  string query_name = 4;
  optional bytes context = 5; //
}

message QueryResult{
  bytes agent_id = 1; //32 bytes, of actor_id type
  bytes actor_id = 2; //32 bytes, actor_id
  string query_id = 3; //correlation_id for this query, must match the ActorQuery
  oneof result { //can be a tree_id, or the actual blob data
    //blob_id or tree_id (see Grit Query)
    bytes result_id = 10;
    //valid Grit blob object  
    bytes result_blob = 11; 
    string error = 12;
  }
}


message ApexToWorkerMessage {
  enum MessageType {
    PING = 0;
    GIVE_AGENT = 10; // give to worker
    YANK_AGENT = 11; // take from worker
    INJECT_MESSAGE = 20; // send a message to an agent
    QUERY = 30;  //send a query to an agent
  }

  //always required
  MessageType type = 1;

  oneof payload {
    AgentAssignment assignment = 10; // GIVE_AGENT, YANK_AGENT
    MessageInjection injection = 20; // INJECT_MESSAGE
    Query query = 30; // QUERY
  }
}

message WorkerToApexMessage {
  enum MessageType {
    PING = 0;
    READY = 1; // start receiving messages from apex
    //MANIFEST_UPDATE = 2; // send a manifest update to apex (esp, when capacity changes)
    RETURN_AGENT = 11; // return agent to apex
    // ACTOR_MESSAGE = 10; //the recipient is not on the worker and the message needs to be routed by apex
    QUERY_RESULT = 30;  
  }

  //always required
  MessageType type = 1;
  string worker_id = 2;
  string ticket = 3;

  oneof payload {
    WorkerManifest manifest = 10; //READY event
    AgentAssignment assignment = 11; //RETURN_AGENT
    QueryResult query_result = 30; // QUERY_RESULT
  }
}